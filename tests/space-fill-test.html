<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <title>BAM Space Filling Test</title>
  
  <!-- jQuery and LoDash are dependencies -->
  <script src="../../sherpa/jquery-2.0.3.min.js"></script>
  <script src="../../sherpa/lodash-2.0.0.min.js"></script>
  <script src="../../sherpa/has.js"></script>
  
  <script type="text/javascript" src="../../phetcommon/js/util/query-parameters.js"></script>
  
  <!-- Our code, in either the concatenated 'with comments' version or the minified version -->
  <script data-main="../js/build-a-molecule-config.js" src="../../sherpa/require-2.1.8.js"></script>
  
  <style type="text/css">
    .scene {
      float: left;
      margin-left: 5px;
      position: relative; /* trigger correct positioning inside the scene */
      background-color: #fff;
      z-index: 0;
      padding: none !important; /* in case we add jQuery Mobile back in */
      border: 1px solid black;
    }
    
    #can {
      width: 512px;
      height: 512px;
    }
  </style>
</head>

<body>
  
  <h1>BAM Space Filling Test</h1>
  
  <canvas id="can"></canvas>
  
  <script>
    var canvas = document.getElementById( 'can' );
    canvas.width = 512;
    canvas.height = 512;
    var context = canvas.getContext( '2d' );
    
    function check() {
      if ( window.loadedBuildAMoleculeConfig ) {
        // make sure the full sim code doesn't launch immediately
        window.delayBuildAMoleculeLaunch = true;

        require( [ 'build-a-molecule-main', 'BAM/namespace', 'SCENERY/main', 'KITE/main', 'DOT/main', 'PHET_CORE/main', 'NITROGLYCERIN/Element', 'BAM/model/CompleteMolecule', 'DOT/Matrix3', 'DOT/Vector3', 'KITE/segments/EllipticalArc' ],
          function( bleh, bam, scenery, kite, dot, core, Element, CompleteMolecule, Matrix3, Vector3, EllipticalArc ) {
            
          window.bam = bam;
          window.scenery = scenery;
          window.kite = kite;
          window.dot = dot;
          window.core = core;
          
          // var generalTest = MoleculeList.getMasterInstance().findMoleculeByCID( 23418945 );
          // var hcn = MoleculeList.getMasterInstance().findMoleculeByCID( 768 );
          var hcn = CompleteMolecule.fromSerial2( 'hydrogen cyanide|CHN|768|full|3|2|N 3.403 0.405 -0.58 0 0|C 2.5369 -0.095 0.58 0 0,0-3|H 2.0 -0.405 1.645 0 0,1-1' );
          var big = CompleteMolecule.fromSerial2( 'dimethylphosphoryloxy(dimethyl)phosphine|C4H12O2P2|23418945|3d|20|19|P -1.2703 -0.0791 -0.0060|P 1.6184 0.0953 0.6201|O 0.2532 0.4317 -0.1773,0-1,1-1|O -1.4175 -1.5612 0.1777,0-2|C -1.9147 0.8899 1.3416,0-1|C -2.0608 0.5368 -1.4786,0-1|C 2.0317 -1.508 -0.1719,1-1|C 2.7599 1.1945 -0.3056,1-1|H -1.4013 0.645 2.2755,4-1|H -1.7872 1.9591 1.1492,4-1|H -2.9818 0.6925 1.4763,4-1|H -1.6306 0.0687 -2.3684,5-1|H -3.1319 0.3176 -1.4578,5-1|H -1.9348 1.6198 -1.5652,5-1|H 1.3532 -2.2924 0.1748,6-1|H 3.0516 -1.8082 0.0858,6-1|H 1.957 -1.45 -1.2619,6-1|H 2.5488 2.2424 -0.0728,7-1|H 2.6613 1.0599 -1.3869,7-1|H 3.7977 0.9883 -0.028,7-1' );
          
          function ellipticalArcCut( ra, rb, d, theta ) {
            if ( theta > Math.PI / 2 ) {
              // other one is in front, bail!
            }
            
            // 2d circle-circle intersection point
            var ix = ( d * d + ra * ra - rb * rb ) / ( 2 * d );
            var iy = ra * Math.sqrt( 1 - ix * ix / ( ra * ra ) );
            
            // elliptical arc center
            var cx = ix * Math.sin( theta );
            var cy = 0;
            
            // elliptical semi-minor/major axes
            var rx = iy * Math.cos( theta );
            var ry = iy;
            
            var cutoffTheta = Math.atan2( ix, iy ); // yes, tan( ix/iy ) converts to this, don't let your instincts tell you otherwise
            
            if ( theta < cutoffTheta - 1e-7 ) {
              // no arc needed
              return null;
            }
            
            var nx = ix / ( ra * Math.sin( theta ) );
            
            // start angle for our elliptical arc (from our ra circle's parametric frame)
            var psi = Math.acos( nx );
            
            // start angle for our elliptical arc (from the elliptical arc's parametric frame)
            var alpha = Math.atan2( ra * Math.sqrt( 1 - nx * nx ) / ry, ( ra * nx - cx ) / rx );
            
            return {
              ix: ix,
              iy: iy,
              cx: cx,
              cy: cy,
              rx: rx,
              ry: ry,
              nx: nx,
              psi: psi,
              alpha: alpha
            };
          }
          
          // HCN
          var n = dot( hcn.atoms[0].x3d(), hcn.atoms[0].y3d(), hcn.atoms[0].z3d() ).times( 70 ); // to picometers from angstroms? hopefully?
          var c = dot( hcn.atoms[1].x3d(), hcn.atoms[1].y3d(), hcn.atoms[1].z3d() ).times( 70 ); // to picometers from angstroms? hopefully?
          var h = dot( hcn.atoms[2].x3d(), hcn.atoms[2].y3d(), hcn.atoms[2].z3d() ).times( 70 ); // to picometers from angstroms? hopefully?
          
          n.element = Element.N;
          c.element = Element.C;
          h.element = Element.H;
          
          n.radius = n.element.radius;
          c.radius = c.element.radius;
          h.radius = h.element.radius;
          
          n.color = n.element.color;
          c.color = c.element.color;
          h.color = h.element.color;
          
          function step( timeElapsed ) {
            var rot = Matrix3.rotationY( timeElapsed );
            rot.multiplyVector3( n );
            rot.multiplyVector3( c );
            rot.multiplyVector3( h );
          }
          
          function draw() {
            var width = 512;
            var height = 512;
            var midX = width / 2;
            var midY = height / 2;
            // context.clearRect( 0, 0, width, height );
            context.fillStyle = '#000';
            context.fillRect( 0, 0, width, height );
            
            var atoms = _.sortBy( [h,c,n], function( v ) { return v.z; } );
            
            for ( var i = 0; i < atoms.length; i++ ) {
              var atom = atoms[i];
              
              var arcs = [];
              
              // check each atom behind this one for occlusion
              for ( var k = 0; k < i; k++ ) {
                var otherAtom = atoms[k];
                
                var delta = otherAtom.minus( atom );
                var d = delta.magnitude();
                if ( d < atom.radius + otherAtom.radius - 1e-7 ) {
                  var theta = delta.angleBetween( dot( 0, 0, -1 ) );
                  var arcData = ellipticalArcCut( atom.radius,  otherAtom.radius, d, theta );
                  if ( arcData ) {
                    // angle to center of ellipse
                    var phi = Math.atan2( delta.y, delta.x );
                    var center = dot( arcData.cx, arcData.cy ).rotated( phi );
                    arcs.push( {
                      center: center,
                      rx: arcData.rx,
                      ry: arcData.ry,
                      rotation: phi,
                      circleStart: phi - arcData.psi,
                      circleEnd: phi + arcData.psi,
                      ellipseStart: -arcData.alpha,
                      ellipseEnd: arcData.alpha
                    } );
                  }
                }
              }
              
              arcs = _.sortBy( arcs, function( arc ) { return arc.circleStart; } );
              
              context.fillStyle = atom.color;
              context.beginPath();
              
              if ( arcs.length ) {
                for ( var j = 0; j < arcs.length; j++ ) {
                  var ellipticalArc = new EllipticalArc( arcs[j].center.plus( dot( atom.x + midX, atom.y + midY ) ),
                                                         arcs[j].rx, arcs[j].ry,
                                                         arcs[j].rotation,
                                                         arcs[j].ellipseStart, arcs[j].ellipseEnd, false );
                  ellipticalArc.writeToContext( context );
                  var atEnd = j + 1 === arcs.length;
                  context.arc( atom.x + midX, atom.y + midY, atom.radius, arcs[j].circleEnd, atEnd ? ( arcs[0].circleStart + Math.PI * 2 ) : arcs[j+1].circleStart, false );
                }
              } else {
                context.arc( atom.x + midX, atom.y + midY, atom.radius, 0, Math.PI * 2, false );
              }
              context.fill();
            }
          }
          
          var lastTime = 0;
          var timeElapsed = 0;
          function tick() {
            window.requestAnimationFrame( tick, canvas );
            
            var timeNow = new Date().getTime();
            if ( lastTime != 0 ) {
              timeElapsed = (timeNow - lastTime) / 1000.0;
            }
            lastTime = timeNow;
            
            step( timeElapsed );
            draw();
          }
          window.requestAnimationFrame( tick, canvas );
        } );
      }
      else {
        setTimeout( check, 4 );
      }
    }
    setTimeout( check, 4 );
    
  </script>

</body>
</html>
